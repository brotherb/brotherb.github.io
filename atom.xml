<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Spike's Blog]]></title>
  <subtitle><![CDATA[Keep It Simple]]></subtitle>
  <link href="http://brotherb.info/atom.xml" rel="self"/>
  <link href="http://brotherb.info"/>
  <updated>2013-11-10T18:27:16.451Z</updated>
  <id>http://brotherb.info/</id>
  <author>
    <name><![CDATA[Spike]]></name>
    <email><![CDATA[brotherbigger@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[读「佛，到底讲了些什么」有感]]></title>
    <link href="http://brotherb.info/2013/11/10/readbuddha/"/>
    <id>http://brotherb.info/2013/11/10/readbuddha/</id>
    <published>2013-11-10T14:48:29.000Z</published>
    <updated>2013-11-10T18:27:07.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>
<p>在进入研一之后，我发现自己读的书真的很少，尤其是在人文方面，因此，我决定没事的时候多读一点书，变得理智一点，提高自己的情商。<strong>我一个喜欢读书的舍友</strong>对我影响很大，坚定了我读书的信念。在他的影响下，我接触了正版的电子书，而不是网上随便down一个pdf，或者txt。因为花了钱的东西，总会比较珍视，况且现在觉得，一部iphone土豪金对自己的价值可能真的不如一部好书，并且后者没那么贵，也不需要炒，使用寿命也特别长，甚至是一生受用的。</p>
<p>近几年，为了缩小体积，携带方便，数字化阅读的发展前景可谓是一往无前，对传统纸媒也造成了巨大的冲击。这里推荐2个应用吧，我使用多看阅读和豆瓣阅读。关于现在众多的电子书app的对比，这里有一个比较好的<a href="http://www.zhihu.com/question/20933281/answer/17366556" target="_blank">回答</a>。我主要使用多看，因为豆瓣阅读偏文艺的书居多，多看里面的书比较对我的胃口。此外，多看常搞特价，里面每天限时免费一本书，很划得来。<a id="more"></a></p>
<h2>宗教</h2>
<p>一直以来，我对宗教都怀有一种好奇心。宗教是如此的神秘，以至于可以控制人的思想。从前我一直觉得法轮功是一个很扯淡的东西，传销是一个很扯淡的东西，可现在觉得我真是大言不惭。如果我去学了，可能真的就信了！</p>
<p>我看过很多有关宗教的电影，对我影响比较大的是<a href="http://movie.douban.com/subject/1309071/" target="_blank">「天国王朝」</a>。为了一座城，几十万人能连命都不要。我的好奇是情有可原的，小时候作为祖国的花朵，我努力学习科学文化知识，认为科学技术是第一生产力，宗教==迷信等等。同时，中国，尤其是现代中国，并不适合发展宗教的。甚至连佛教也逐渐腐化了。人们忙于追名逐利，户口，房子，车子，奶粉钱，这才是重点！没钱就去喝西北风。</p>
<p>最早的印度佛教教义里规定，出家人，不能耕地，不能持银钱，只能乞食。现在看来几乎是无法想象的，一个现代人让他去要饭，简直比杀了他还难受！还不如去死！</p>
<p>但我现在看到的，完全不同了。大大小小的寺庙开始发展旅游业，都有功德箱了，一柱高香（小腿粗细，长度超过1米5,真特么高）要一千多。口中有佛，心中无佛的大有人在。真正研究佛法的佛教徒越来越少。</p>
<h2>佛，到底讲了些什么？</h2>
<p>这本书叫做<a href="http://read.douban.com/ebook/475730/" target="_blank">「佛，到底讲了些什么？」</a>,￥5.99。我现在还没看完，看到了非常晦涩难懂的地方。我就对已经看了的40%做一个评价吧。</p>
<p>这本书主要讲了汉传佛教的历史，真的是让我大开眼界，颠覆了我20多年来对佛的认识。因为从小到大接触到的影视剧和一些文学作品中有关佛教的刻画十分之七八是错的。</p>
<p>关于佛学长久以来的发展和演变，内容实在太多，最好去看原文。这里只介绍两个佛教最基本的思想。</p>
<p>首先，是哲学思想——万法缘起。</p>
<p>其次，是神学（其实也算是哲学，不过是一种唯心主义的思想）思想——六道轮回。</p>
<p>佛教的最终修行目的——消灭一切欲望，脱离六道轮回。</p>
<p>我认为，这是一本能开阔视野，启发人思考，提高思辨能力和想象力的书。因为佛教不同于别的教，佛教偏哲学多一些，逻辑非常严密。而别的教多数是基于神学的，比如基督教一上来就是“上帝说要有光，就有了光”云云。</p>
<p>此书不但有料，而且有趣，讲的非常生动，不枯燥，是一本极好的课外读物。</p>
<p><strong>如果你问我，读这本书学到了什么？</strong></p>
<p>且不说我还没看完这本书，就算我看完了，也只是能学到一些皮毛而已。佛学博大精深，我不能不服。佛学，泛化到哲学，是平常人穷极一生都难以明白的。因为它们似乎在回答一些不是问题的问题。但是，佛教认为真理是语言无法形容的，所以，佛学是一个不断否定的过程，它不能说真理是什么，只能说真理不是什么，只有不停地否定下去，才能不断地接近真理。</p>
<p>A：万法皆实吗？</p>
<p>B：肯定不对，根据“万法缘起”，你看到的都是虚妄！万法皆空才对！</p>
<p>C：如果万法皆空，那佛祖是空，佛经也是空，教义也是空，那还修行个甚！我看空也不空，有也没有，应该叫假有！</p>
<p>D:…</p>
<p>（我都想拍桌了！）</p>
<p>我现在看到了佛学对时间和空间的研究，觉得真是屌炸天啊。纯靠想的。因为科学依赖的是实验和观测。但佛教看来，你看到的，听到的，闻到的等等都是<a href="http://baike.baidu.com/link?url=Hz-td9brWdth27eNacYU9CzjKWTzNfI6bOPKVaOM3nW-r3jiiAVP33wkQMUk3m0I" target="_blank">六识</a>产生的幻觉，都是假的，那怎么算数的呢？（我又想拍桌了！）</p>
<h2>保持内心平和</h2>
<p>对于我这样一个从小相信科学技术的好少年来说，我是<strong>不轻易相信</strong>佛学的那一套的。但是如果拿出对我有利的部分加以利用，则有很大的裨益。</p>
<p>佛至少说对了一点，人都有欲望，有欲望就有痛苦。满足欲望获得快乐，但那是暂时的，并且你不一定能满足的了，满足了也产生新的欲望。但我不同意一切都是虚妄，也不想消灭一切欲望。人生就是一段苦与乐的旅途，我们需要苦和乐来确认我们是真的活着。</p>
<p>我们要做的是，抑制错误(极大几率无法满足)的欲望。俗话说的好，人之所以痛苦，在于追求错误的东西。而我们有时候会<strong>执</strong>，会不理智、不清醒，从而导致痛苦。这时候要<strong>放下</strong>。在人生中，战斗何其多，但我只打值得去打的仗。我一个同学说的好，人生虽然很长，但是紧要处只有几步。</p>
<p>但是，我也很欣赏另一句话：人之所以痛苦，在于对自己无能的愤怒。</p>
<p>这两句话一句让人释怀，一句催人奋进，究竟怎么做，要有个度，这就是我所理解的情商。</p>
<p>永远使自己保持最平和的心态，戒嗔！心态不好的时候，胸中念一句：</p>
<blockquote>
<p>一切有为法， 如梦幻泡影，如露亦如电， 应作如是观。（出自《金刚经》）</p>
</blockquote>
<p>负面情绪就不攻自破了。</p>
<h3>最后，分享一篇好文：<a href="http://www.douban.com/group/topic/3748955/" target="_blank">我的信仰地图</a></h3>
]]></content>
    <category scheme="http://brotherb.info/tags/读书/" term="读书"/>
    <category scheme="http://brotherb.info/tags/思考/" term="思考"/>
    <category scheme="http://brotherb.info/tags/生活/" term="生活"/>
    <category scheme="http://brotherb.info/tags/哲学/" term="哲学"/>
    <category scheme="http://brotherb.info/categories/读书/" term="读书"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[我的python环境配置]]></title>
    <link href="http://brotherb.info/2013/10/30/setup-python-env/"/>
    <id>http://brotherb.info/2013/10/30/setup-python-env/</id>
    <published>2013-10-30T07:49:00.000Z</published>
    <updated>2013-10-30T16:13:24.000Z</updated>
    <content type="html"><![CDATA[<p>我使用ubuntu12.04,系统自带的python版本是2.7.3。在/usr/bin目录下面。不要动它，如果2.7.3可以满足需要，就看下面的一般配置就足够了。</p>
<h2>一般配置</h2>
<ol>
<li>安装setuptools</li>
<li>安装pip</li>
<li>安装virtualenvwrapper(用pip，pip会自动安装目标包的依赖包如virtualenv等)</li>
<li>配置好virtualenvwrapper(见<a href="http://virtualenvwrapper.readthedocs.org/en/latest/" target="_blank">官方文档</a>),并创建一个隔离的python环境(以后一般的工作都在这个环境中进行，假定这个环境的名字是dev)。</li>
<li>进入dev。</li>
<li>sudo apt-get install Python-dev(下一步中安装pyzmq需要这一步)</li>
<li>安装ipython, pyzmq, jinja2, tornado(这一步是为了安装ipython notebook)</li>
</ol>
<p>这样python的环境基本就配置好了，一般使用ipython notebook作为自己的repl，这个相当给力（此前我一直使用ipython qtconsole，但用了notebook之后，感觉qtconsole弱爆了）。<a id="more"></a></p>
<p><strong><em>FAQ</em></strong></p>
<p>为什么要用virtualenv？</p>
<p>答：系统自带的python，它的包搜索路径下有很多ubuntu系统自带的包，而这些包对我们做开发是不需要的。如果你装了pip，可以用pip freeze命令查看当前版本python安装了哪些packages。简单来说，我就是看着这些多余的东西很不爽，所以自己弄一个环境，里面只有自己需要的包，很清爽。更深层次的原因，virtualenv可以解决包的版本依赖问题，比如A和B都依赖第三方的C包，但是依赖的C包的版本又不同。<strong>注意：virtualenv只能解决包版本依赖问题，它不是一个python的版本管理器。</strong></p>
<h2>python版本管理</h2>
<p>如果我既要使用python2.7,又要使用3.3怎么办？这里我介绍3种方法。</p>
<p><strong>1. 不好的做法</strong></p>
<p>下载相应版本的python源代码(这里假定就是python3.3.2)，安装。一般来讲就是3板斧：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>./configure
<span class="title">make</span>
<span class="title">sudo</span> make install
</pre></td></tr></table></figure>

<p>然后，python3.3就装到/usr/local/bin目录下面了(如果编译的时候不指定prefix的话，默认的路径就是/usr/local/bin)。在我的环境变量$PATH里，/usr/local/bin是排在/usr/bin前面的，所以我的系统的默认python就成了新安装的python3.3了。</p>
<p>下图是我的/usr/local/bin和/usr/bin目录：</p>
<p><img src="../../../../images/20131030/1.png" alt=""></p>
<p>切换2.7和3.3，就像是在玩一个游戏，很无聊的一个游戏。本质上就是决定python这个命令到底指的是谁？方法有很多，做软链接、修改/usr/local/bin和/usr/bin的顺序（即选择命令的优先级），或者干脆输入的时候指定python的版本，如python2,python2.7，python3,python3.3等等(但我很讨厌多敲这么些个字母)。</p>
<p>这个做法缺点比较明显，主要有以下几点：</p>
<ol>
<li>你替换了系统的python，可能会导致很多问题，因为ubuntu其实集成了很多python有关的东西，修改系统的python版本可能会出问题。比如ibus输入法(当然，我现在已经不用ibus了，但这不代表别的其他软件不会出问题)。</li>
<li>切换麻烦。不止是python有2.7和3.3之分，virtualenv，pip，easy_install其实都对应着一个python的版本，上图已经展示得很清楚了。后面不带版本号的命令其实就是带版本号的命令的一个拷贝。你python命令改了(比方从3.3改回了2.7），pip什么的也得跟着改，不然，你虽然用的是2.7的python，但你pip install的时候，调用的还是pip3.3，还是为python3.3装包。所以，改的地方很多。我想过写一个脚本来做，但是觉得很不优雅。而且，每当你安装新的python软件，比如ipython，这个脚本都要添加相应的切换命令。</li>
</ol>
<p>所以我说，这是一种不好的做法，一种非常低端的做法。</p>
<p><strong>2. 好的做法</strong></p>
<p>使用<a href="https://github.com/yyuu/pyenv" target="_blank">pyenv</a>,<a href="https://github.com/saghul/pythonz" target="_blank">pythonz</a>或者<a href="https://github.com/utahta/pythonbrew" target="_blank">pythonbrew</a>。其中，pythonbrew已经长期无人打理了，作者建议使用pyenv。</p>
<p>我这里使用了pyenv，这是一个日本人(一个shell hacker)做的，文档写的非常认真，非常细致，包括这个工具的基本实现原理都讲得清清楚楚。pyenv是纯粹的shell脚本写的，不依赖于python。</p>
<p>它包含最基本的安装、卸载和切换python版本。一般的工具，切换了python版本，其实是整个全局都换了，不管在哪都是这个版本。但pyenv<strong>最牛逼的地方</strong>，就是能够指定，在哪个目录下用哪个版本的python，屌爆了有没有？比如，我有个项目要用python3,我就cd到这个项目目录，然后输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">pyenv</span> local <span class="number">3</span>.<span class="number">3</span>.<span class="number">2</span>
</pre></td></tr></table></figure>

<p>那么当我进入这个目录的时候，python版本就变成了3.3.2,出去以后就是别的。</p>
<p>此外，pyenv还支持Cpython以外的其他平台的python实现，如Jython，Pypy等等。如果想用，直接去看它的文档吧，我就不翻译了。</p>
<p><strong>3. 最好的做法</strong></p>
<p>虽然在「好的做法」这一节，我折腾的很high。但是当我打开<a href="http://www.jetbrains.com/pycharm/" target="_blank">Pycharm</a>的时候，我发现我讲的大多是多余的。当然了，如果你是Vimer或者Emacser这种硬核玩家，那么前面的内容是非常有用的。</p>
<p>Pycharm提供了强大的功能，帮助你管理你的python版本。每一个工程，你都可以选择想要的python interpreter。选择了这个以后，剩下的你就不用管了，Pycharm帮你打理好了一切，包括pip，ipython，这些工具对应的版本都自动的帮你调过来了。</p>
<p>细细想来，其实我们花了很多时间去做一些吃力不讨好的事情，但是这些事情跟我们要开发的东西没有任何关系，IDE的作用就是帮我们打理好一切，让我们专注于真正要做的事情，要实现的功能。不要给自己添麻烦，用最有效的，而不是最复杂的，最难的。</p>
<p><strong>ps：我真的不是来打广告的。</strong></p>
]]></content>
    <category scheme="http://brotherb.info/tags/python/" term="python"/>
    <category scheme="http://brotherb.info/tags/折腾/" term="折腾"/>
    <category scheme="http://brotherb.info/categories/python/" term="python"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[函数式编程浅见]]></title>
    <link href="http://brotherb.info/2013/10/16/aboutfp/"/>
    <id>http://brotherb.info/2013/10/16/aboutfp/</id>
    <published>2013-10-16T13:54:22.000Z</published>
    <updated>2013-10-16T15:23:35.000Z</updated>
    <content type="html"><![CDATA[<p>在暑假里我阅读了《黑客与画家》一书。书中作者描述了他的创业之路，其中他认为他能够创业成功，很大程度上靠的是他使用Common Lisp语言开发，因此获得了技术优势，使他的产品可以快速开发，快速迭代，并且难以复制。在黑客与画家最后几章里，作者Paul Graham基本都是在夸奖Lisp语言设计的精妙，思想的先进和超前，特性的优良，这与王垠的某些观点不谋而合。并且Paul认为，lisp是未来编程语言的发展方向。真的是这样吗？<a id="more"></a></p>
<p>函数式编程是一种古老的编程范式，它在上个世纪五六十年代就发明了出来。Lisp是除Fortran以外第二古老的编程语言。但是不管是这种语言还是这种思想，在工程领域一直没有成为主流。现如今到了21世纪，函数式编程仿佛焕发了生机，被炒的相当热。对于这个现象，业界褒贬不一。此前我也提到，不少程序员喜欢装逼，当别人在讨论面向对象的时候，他们蹦出来侃侃而谈，痛批面向对象哲学的丑陋，赞颂函数式编程的优雅，嘴里说一些JAVA程序员听不懂的词语，如S表达式，惰性求值，类型推导，高阶函数，闭包等等(看着很像数学对吧？)，给人一种高人一等的感觉。这样的(没有意义的）讨论很大程度上是对函数式编程的一种过分夸大。就像是不管什么游戏，下面总有脑残(更有可能是腾讯的水军)嚷嚷说是抄袭CF，其实就是一种宣传。</p>
<p>我是一个编程语言爱好者，但我不是任何一种编程语言的死忠。我最早是从王垠的文章中了解到函数式编程，在暑假里，我阅读了计算机程序的构造与解释的第一章(觉得很难啊)，学习了一些基本的scheme，并可以用它解决一些简单的问题。后来在寻求一种实用的FP语言的过程中，我认识了Clojure，还算认真地学了一段时间，并且完成了<a href="http://www.4clojure.com/problems" target="_blank">4clojure</a>上的一些练习题，我的solution已经分享到<a href="https://github.com/brotherb/4clojure" target="_blank">Github</a>上了(如果读者你有其它有趣的solutions，欢迎与我交流)。</p>
<p>上手函数式编程，一开始给我的感觉是，有趣，强大，像是在玩数学游戏(具体的感受，做几道4clojure就体会到了)。它很适合解决递归问题，如这道<a href="http://www.4clojure.com/problem/106" target="_blank">深搜</a>或者求一个集合的全部子集这样的问题。可是过了一些时候，我发现它很难解决另外一类问题。这类问题的一个共同点就是，需要利用“副作用”来做，而函数式编程从本质上抵制副作用，不允许你使用，这也是它一个的卖点。比如我们知道，有一些动态规划问题，可以用等价的递归+打表(记忆方法)来解决。但是用纯粹的函数式的思维来说，很难解。因为根本就没有变量这种东西，也就没有表去供你去记录和改变状态。当然，Clojure是可以的，它提供了一个叫缓存的东西，还有一个memorize函数去记录计算过程中的一些中间值。Scheme我不知道，我猜也会有一种方法去记录一些东西。但是它提倡的彻底消灭“副作用”的主张就不能自圆其说了。</p>
<p>所以很多利用“副作用”的算法，就不合适用函数式编程思想来做(虽然能做)。用C语言来做就是a piece of cake。</p>
<p>但是，函数式编程又有它强大的一面，篇幅限制，这里我不打算科普函数式编程的常识，如果有心，你可以去阅读一些科普性的文章，它们到处都是。比如<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank">这一篇</a>。</p>
<p>软件工程学一直以来都在致力于解决两个问题:</p>
<ol>
<li>如何控制软件的复杂度</li>
<li>如何复用代码</li>
</ol>
<p>为此，产生了面向对象这种编程思想。但是，很多函数式编程的支持者认为，函数式编程具备更强的抽象能力。王垠对于面向对象几乎是<a href="http://www.zhihu.com/question/19728806" target="_blank">深恶痛绝</a>的。但是，我听起来觉得像是忽悠人的。因为，并没有任何可靠的证据证明两者在“抽象能力”上的差距。相反，很多大家耳熟能详的优秀的大型软件都是面向对象的产物，而函数式编程呢？没听说过。我一直不明白，既然都说Lisp那么牛逼，为什么现在软件开发基本上是C++,JAVA这些语言的天下呢？我昨天看到了一篇<a href="http://www.soimort.org//posts/124/index.html" target="_blank">非常好的文章</a>，也许它可以回答你的问题。</p>
<p>当然，我对函数式编程也只是刚刚接触，以上只是一些非常主观的感受，希望日后可以有新的领悟。</p>
<p>ps：开学一个多月，浑浑噩噩，完全没有学习的状态。为督促自己，以后每周至少一篇博客，以此为证。</p>
]]></content>
    <category scheme="http://brotherb.info/tags/函数式编程/" term="函数式编程"/>
    <category scheme="http://brotherb.info/tags/Clojure/" term="Clojure"/>
    <category scheme="http://brotherb.info/categories/闲聊/" term="闲聊"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[程序员的老生常谈之操作系统]]></title>
    <link href="http://brotherb.info/2013/08/25/programmer's-platitude2/"/>
    <id>http://brotherb.info/2013/08/25/programmer's-platitude2/</id>
    <published>2013-08-25T05:57:45.000Z</published>
    <updated>2013-08-27T09:14:29.000Z</updated>
    <content type="html"><![CDATA[<p>今天早上和发小出去打球，意外扭伤了脚踝，回了家网络也不好，百无聊赖之际，就想写点东西。</p>
<p><a href="http://brotherb.info/2013/07/27/programmers-platitude1/">上篇文章</a>里，我大致谈了我对开发工具的一些看法，以及我比较喜欢的开发工具。本文主要谈谈我对操作系统的看法，其中不涉及任何有关内核、原理等方面的内容，单纯地从一个使用者的角度来谈。<a id="more"></a></p>
<h2>Linux</h2>
<h3>折腾历史</h3>
<p>第一次接触Linux是在2010年夏天，那时学院里面组织一些同学去大连东软参加实训。期间，我们要开发一个Linux下的即时通讯软件，我们在虚拟机中安装了Red Hat Linux，使用vi写代码。当时是十分痛苦的，因为vi很难用。我当时采取的办法是在虚拟机外面用vs写代码，然后拖到虚拟机里面编译。现在想来真是幼稚、低端。</p>
<p>第二次接触Linux是2010年冬天到2011年夏天，当时我参加了<a href="http://en.wikipedia.org/wiki/RoboCup_2D_Soccer_Simulation_League" target="_blank">Robocup 2D仿真组</a>的比赛。其中，我们需要在Ubuntu10.04上面安装仿真平台、工具等，并调试球队。那个时候算正儿八经用Linux了，学习了基本的命令，在不清楚原理的情况下照猫画虎编写了第一段shell脚本。</p>
<p>之后一直在使用Linux，但是仅仅局限于尝试各种Linux发行版、开源软件。那个时候正值大三，上的课听不懂，下来也不好好学。除了打游戏，就是折腾系统了。当时把折腾的心得写成了一篇<a href="http://user.qzone.qq.com/1078039894/#!app=2&amp;via=QZ.HashRefresh&amp;pos=1340298002" target="_blank">日志</a>，现在觉得认识比较浅薄，当笑话看吧！</p>
<p>今年4月份，也不知为何心血来潮，就想玩玩<a href="https://www.archlinux.org/" target="_blank">archlinux</a>，它和<a href="http://www.gentoo.org/" target="_blank">Gentoo</a>都是比较好玩的。但是后者我没敢玩，那个需要长时间的编译等待，中间还有出错的可能。</p>
<p>算下来，我使用过的Linux发行版有那么七八种。现在我使用两种，笔记本上的Arch和台式机上的Ubuntu。</p>
<h3>Linux发行版</h3>
<p>其实，我们常说的Linux指的是Linux发行版，即Ubuntu，Fedora这些。Linux发行版的多达几百种(详情请看<a href="distrowatch.com">这里</a>)。而Linux只是一个内核的名字而已。一个Linux发行版是由Linux内核和运行在其上的应用软件构成的。</p>
<p>首先，不同发行版的内核是不尽相同的。当然我并不是指，Linux内核的源代码有很多种。<a href="https://github.com/torvalds/linux" target="_blank">Linux源码</a>只有一份，控制在他的创造者linus torvalds手中。但是，Linux内核在编译时有很多选项可以选择，如果用来做桌面||服务器系统，就多选择一些功能;如果做嵌入式系统，就精简一些。同时，也有很多参数可以设置，如网络参数，文件系统参数等等，老是说centos做服务器比较“稳定”，可能就在内核参数上做了一些调整(当然，应该远不止这些，应用软件也都应该是最稳定的版本)。</p>
<p>其次，不同的发行版使用不同的应用软件。其中比较重要的有：</p>
<ol>
<li>包管理器(PM, package manager)</li>
<li>桌面环境(DE, desktop environment)</li>
<li>窗口管理器(WM, windows manager)</li>
<li>显示管理器(DM, display manager)</li>
<li>系统和服务管理器(system and service manager)</li>
<li>软件中心(software center)</li>
<li>……</li>
</ol>
<p>具体哪个发行版使用那些软件这里就不细说了。同一个发行版的不同的版本，采用的应用软件也不尽相同。当然，桌面环境的不同，人们一眼就看出来了，很多人误以为那就是不同的Linux，其实就是同一个操作系统里装了不同的桌面环境而已(甚至是同一个桌面环境，但只是把主题改了一下，加了些Dock之类的applet而已)。感兴趣的可以自行google，自己装一些玩玩。我自己玩Arch的时候尝试了大部分主流的桌面环境和窗口管理器，但后来还是因为没什么耐心去玩主题，换回了KDE。</p>
<h3>使用感受</h3>
<p>我不知道有多少人使用Linux是因为受到了王垠的<a href="http://www.chinaunix.net/old_jh/46/293550.html" target="_blank">这篇文章</a>的影响(后来他又写了<a href="http://blog.sina.com.cn/s/blog_5d90e82f0101ip7f.html" target="_blank">另一篇文章</a>推翻了前者)。就我而言，我没有任何<a href="http://brotherb.info/2013/08/01/how-religion-destroys-programmers/">信仰</a>。我只选择最合适的。</p>
<p>由于只是个人使用，没玩过服务器，没玩过高性能计算，Linux和Windows在性能和稳定性方面的差异，我没什么发言权。日常使用方面，如果不玩游戏不用网银(可惜，这是不可能的。:))，Linux可以代替Windows，这是没问题的。以下是我能想到的Linux的优点：</p>
<ol>
<li>免费。</li>
<li>命令行十分强大，系统配置方便，对开发者友好。</li>
<li>得益于<a href="http://en.wikipedia.org/wiki/Virtual_file_system" target="_blank">虚拟文件系统(VFS)</a>，Linux可以直接读写NTFS文件系统，这是Linux的先进之处。而Windows要读写ext文件系统，则需要借助第三方软件。</li>
<li>安全，不多说了。不过，<strong>对个人用户来讲没什么意义</strong>。用户要是一路sudo，那安全性有没有都一样。我Windows裸奔了几年都没出过事。</li>
<li>定制性强，外围的应用软件想用什么用什么，包括桌面环境。</li>
<li>支持UTF-8。</li>
<li>关机比较快。:)</li>
</ol>
<p>缺点：</p>
<ol>
<li>缺少一些重要软件的替代方案，或者替代方案不够好。如Adobe系列，QQ，迅雷等(别折腾wine，蛋疼死你！)。</li>
<li>部分软件安装比较麻烦。由于发行版众多，包管理器不一，一些软件是以源码的形式提供的，得自己编译安装。而Windows一个.exe就全搞定了。</li>
</ol>
<p>总的来说，Linux是先进的，但是先进的不一定是友好的，尤其是对普通用户来说。</p>
<p><strong>我不会再去折腾Linux的各种发行版和软件了，那除了锻炼你的运维能力(耐心)之外，对你没有任何提高。</strong>理解Linux内核的原理是我下一步要做的事情。</p>
<h2>Windows</h2>
<p>Windows7用着真心不错，这是良心话。我不会天天用它,还不停地骂它。但我不会升级Win8,我认为Win8的战略完全是错的。<strong>统一内核是没有错的，但是妄图统一用户界面和交互方式实在是大错特错</strong>。在没有触屏的笔记本上，用鼠标点击和拖动来模拟触屏，是相当糟糕的用户体验。但是，我非常欣赏Win8在其他方面做的改进。</p>
<p>我觉得如果Windows能在以下方面有所改进，我会非常高兴：</p>
<ol>
<li>更好的命令行。Windows的cmd太糟糕了，虽然后来做了个powershell，能兼容部分Linux命令，但还是太挫了。环境变量的管理也非常差。</li>
<li>拥抱UTF-8标准。Windows的默认标准是Ascii，如果你用VS，你会发现，有时候你写的中文||日文注释被解析成了别的什么东西，会导致一些蛋疼的问题。</li>
</ol>
<p>更多的槽点，可以看看<a href="http://www.cnblogs.com/Chrome/archive/2012/06/07/2539803.html" target="_blank">这篇文章</a>，我觉得是说到了点子上。</p>
<p>当然了，对于一般用户来说，Windows完全够用了，也足够友好。但是对于开发者来说，还远远不够。我不清楚修改这些问题的难度，但是如果这些毛病来源于最初的设计问题，那么要改就要伤筋动骨，甚至推倒重来，那么必然会破坏兼容性，破坏了兼容性，Windows就完了。如何跟上Linux的先进性，又不破坏兼容性，是Windows要考虑的重要问题。不然，你搞100个metro界面出来也白搭，这些都是表面功夫，内在的差距一定会越拉越大。</p>
<h2>OS X</h2>
<p>苹果的OS X我是最不熟悉的。但曾玩过。12年暑假我借了我二姨的macbook pro可劲折腾了一段时间，二姨的mbp装的是xp，唯一的用途是上QQ，以及用PPS看电视，暴殄天物啊，我马上拿过来彻底玩弄了一番。本科毕业前折腾黑苹果未遂。</p>
<p>OS X兼具Linux和Windows的优点，它是对黑客和普通老百姓都非常友好的操作系统。说它是the most advanced OS一点都不为过。</p>
<p>首先，它脱胎于BSD系统，符合POSIX标准，拥有码农们趁手的命令行工具。</p>
<p>其次，大部分软件都有mac版，装软件比windows还简单。试想你一边在命令行里敲命令，一边聊macQQ，一边用迅雷for mac下片，那是多么幸福的事情？并且，部分mac独占的视频||音频处理软件成为了行业标准。苹果电脑成为了设计师标配。</p>
<p>第三，系统很华丽，机器很好看，应用程序很精美。</p>
<p>缺点也有，就是软件数量相对Windows来说要少一些，游戏少。</p>
<p>并且，搭载OS X的机器，售价都偏贵，“学生狗”和屌丝不太能买得起。于是“黑苹果”应运而生。不过我最终因为显卡驱动的问题没折腾成功，待日后挣钱了直接上白的。</p>
<h2>总结</h2>
<p>其实没什么好总结的，所以用非常没水平的一句话来说吧：<strong>各有各的用途</strong>。关键在于我们是什么用户，我们要做什么？</p>
]]></content>
    <category scheme="http://brotherb.info/tags/操作系统/" term="操作系统"/>
    <category scheme="http://brotherb.info/tags/windows/" term="windows"/>
    <category scheme="http://brotherb.info/tags/linux/" term="linux"/>
    <category scheme="http://brotherb.info/tags/osX/" term="osX"/>
    <category scheme="http://brotherb.info/categories/闲聊/" term="闲聊"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[开始软件开发生涯时你需要知道的几件事]]></title>
    <link href="http://brotherb.info/2013/08/23/4-things-i-wish-i-would-have-known/"/>
    <id>http://brotherb.info/2013/08/23/4-things-i-wish-i-would-have-known/</id>
    <published>2013-08-23T05:21:56.000Z</published>
    <updated>2013-11-04T14:56:00.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://simpleprogrammer.com/2013/08/19/software-development-career/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=software-development-career" target="_blank">英文原文：[4 Things I Wish I Would Have Known When I Started My Software Development Career</a>]</p>
<p>我的软件开发生涯开始于大约15年以前。</p>
<p>但仅在最近的5年里，我才真正开始看到我的提高。</p>
<p>下面这些事情，我希望在进入软件开发领域时我已经知道了。如果我早点知道这些事儿，我将会变得更加成功。<a id="more"></a></p>
<h2>软件开发中没有“正确的方式“</h2>
<p>在我开发生涯的早期，我在学习和争论上浪费了大量的时间。我错误地认为，在软件开发的诸多方面都存在一种&quot;绝对正确的方式“。</p>
<p><strong>但是，关于软件开发，几乎每一件我当时认为是正确的事到头来都被证明是错的。</strong></p>
<p>更重要的是，我发现几乎没有任何一件事是非黑即白的。在编写代码和开发软件的过程中，几乎所有的决策都是基于当时特定的情形。</p>
<p>我之前已经谈过<a href="http://brotherb.info/2013/08/01/how-religion-destroys-programmers/">为什么信仰一种技术对开发人员有害</a>，但是我现在说的这个话题谈的不止是一种技术(这么狭隘)。</p>
<p>没有通用的最佳实践，这也是真的。甚至是一些被人们高度重视的话题，如，要不要进行单元测试或敏捷开发和瀑布模型哪个好，也没有永远正确的答案。</p>
<p>在我的生涯中，我在”正道“路线的迷宫里浪费了太多的时间，而不是采用可以帮我走得更远的”务实“路线。</p>
<h2>细读书不是最佳的学习方式</h2>
<p>我一开始学习编程和技术知识的时候，我花了太多时间细读一些关于特定技术的书。</p>
<p><img src="../../../../images/20131104/1.jpg" alt=""></p>
<p>读书没错，但是<strong>选择读什么书和读它的哪一部分非常重要。</strong></p>
<p>比如，我记得我读过一本非常厚的讲VC++的书。(我十分肯定是<a href="http://www.amazon.com/gp/product/1118368088/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1118368088&amp;linkCode=as2&amp;tag=makithecompsi-20" target="_blank">这本书</a>的更早的一个版本。)不管怎么说，这本书是本内容丰富的好书，但是一页一页地读并不是学习VC++最好的方式。</p>
<p>如果我当时先粗略地看看此书的章节，获得对VC++的一些全局的认识，然后再去搞懂其中最最重要的部分，我能学到并记住更多的东西。</p>
<p>如果我当时坐下来，通过实际地做一些东西来练习基础知识，而不是仅仅读一下或者过一过书上的例子，我现在会更加成功。<strong>你没有在真正地学一门技术，除非你用它解决了真正的问题。</strong></p>
<h2>深入学习一门特定技术是浪费时间</h2>
<p>我不仅在”细读书“上浪费了时间，我在”读错书“上也浪费了时间。</p>
<p><strong>我错误地相信，从里到外学习一门特定的技术能很好地推动我的职业生涯。</strong></p>
<p>我花了太多时间读一些非常专门的技术书，如，ASP.NET或Hibernate，而不是读更多的像<a href="">「Code Complete」</a>，<a href="http://www.amazon.com/gp/product/0132350882/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0132350882&amp;linkCode=as2&amp;tag=makithecompsi-20" target="_blank">「Clean Code」</a>，和<a href="http://www.amazon.com/gp/product/0131857258/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131857258&amp;linkCode=as2&amp;tag=makithecompsi-20" target="_blank">「Agile Principles, Patterns, and Practices in C#」</a>。(BTW，我推荐你去读所有的这些书，如果你没读过的话。)</p>
<p><strong>尽管了解你所使用的技术非常重要，但是成为那个特定技术的绝对专家并不重要。</strong>知道确切的API调用没多大好处，你需要的时候可以轻而易举地查到。</p>
<p>我在太多技术上花了太多时间深入学习，最后这个技术不是死掉了就是我后来放弃不用了。大多数关于这些特定技术的知识最后只代表了浪费掉的时间。</p>
<p>我发现，成为你正在使用的特定的程序语言的专家很重要，因为程序语言方面的知识将影响你很长时间。我仍然百分之百会花时间深入学习C++，C#和Java，但是我可能会花较少的时间去学习C++所有复杂的细节，因为那些细节现在对我帮助不大。</p>
<h2>在你的开发生涯中，社区极其重要！</h2>
<p>我的生涯早期，我犯了一个错误，就是不怎么去向社区寻求帮助，也不为他人提供帮助。</p>
<p><img src="../../../../images/20131104/2.jpg" alt=""></p>
<p>我一向乐于帮助我的同事，也在不同的工作岗位上也非常善于交际，但活动范围从来没有超出过公司。</p>
<p><strong>我在我的生涯中花了大量的时间，试图在一个特定的公司进行投资，却没能将我的时间投资在我参与的软件开发社区中。</strong></p>
<p>我花了很多时间，做关于技术或者是最佳实践的内部presentation，而这些时间原本可以用来制作可以服务于社区的内容和材料，同时也能给我带来工作上的认可。</p>
<p><strong>我也犯了另一个错误，就是认为自己没什么有价值的东西去贡献。</strong></p>
<p>我和很多刚入行的开发者聊过，有时候我觉得，比起我们这些”老油条“，他们有更多的东西去贡献给社区，因为他们更理解其他初学者纠结的问题。</p>
<p>如果我可以重来一遍，我一定会在我的生涯中更早、更多地参与各种会议和用户群。我会更早地开始写博客，并利用我的大部分学习时间去建立项目和资源，去帮助别人而不只是自己埋头读书。</p>
<h2>总是参与一个业余项目</h2>
<p>可能我做的最大的，并且对我生涯影响最大的改变是我早些时候完全戒掉了电视、无尽的任务和魔兽世界，并把这部分时间花在一个业余项目上。</p>
<p>我过去花了相当一部分时间做一些享受性的，但是对我的生活没有长远利益的事情。</p>
<p>大约3到4年前，我已经基本不看电视了，现在我也很少看电影。电视和大部分电影只是一个对时间的巨大浪费，而这些时间你可以用来干很多有用的事。视频游戏很大程度上也是一样，但至少在视频游戏里，你在积极地做一些事情，而不是被动地吸收一些没有用的信息。</p>
<p>我会一直热爱玩视频游戏，并且我不认为我会停下来，但是，<strong>我真心希望我(之前)把一大部分用来打游戏看电视的时间花在一个业余项目上。</strong></p>
<p>悲催的是，我做的第一个真正的业余项目是在大约三年前，那时我开始创建我的第一个android应用。</p>
<p>当你在为别人工作的时候，花时间为自己工作非常重要，不然你就是在为他人建立王国而忽视自己的王国。</p>
<p>我不仅从最近几年的业余项目中学到了很多，并且我也从中得到了很多利益。事实上，其中一个，即制作Pluralsight课程，是我现在全力在做的。</p>
]]></content>
    <category scheme="http://brotherb.info/tags/编程感悟/" term="编程感悟"/>
    <category scheme="http://brotherb.info/categories/译文/" term="译文"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[信仰是如何毁掉程序员的]]></title>
    <link href="http://brotherb.info/2013/08/01/how-religion-destroys-programmers/"/>
    <id>http://brotherb.info/2013/08/01/how-religion-destroys-programmers/</id>
    <published>2013-08-01T05:12:03.000Z</published>
    <updated>2013-08-24T08:28:27.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://simpleprogrammer.com/2013/07/08/how-religion-destroys-programmers/" target="_blank">英文原文：[How Religion Destroys Programmers</a>]</p>
<p>我发现了关于我自身的一些东西——我有一个牛逼的天赋，就是我总能在技术上做出最好的选择。<a id="more"></a></p>
<p><img src="../../../../images/20130801/1.jpg" alt=""></p>
<p>哦，不是牛逼，是相当牛逼。</p>
<p><strong>回首我的开发生涯，我认为我使用的任何一种编程语言都是当时情景下最好的那一个。</strong></p>
<p>同样的，我选择的框架，甚至操作系统也是最好的。</p>
<p>是的，我有这个惊人的能力，就是从技术的海洋中挑出最好的(这些技术我甚至不用亲自试一遍)并极力捍卫我的选择。</p>
<p>可能当你在阅读本文的时候，你已经发现了你也有这种神秘的能力。</p>
<h2>大多数开发者有技术信仰</h2>
<p>这是真的。</p>
<p>不要感到丢脸，你不是一个人。我自己，和几乎每一个人，与你同在。</p>
<p><img src="../../../../images/20130801/2.jpg" alt=""></p>
<p>我们中的一些人已经脱离了自我洗脑。另一些人则非常幸福地并没有意识到我们所处的困境。但是我们中的大部分人至少拥有一个为自己制作的信仰。</p>
<p>这是非常正常的，因为大多数程序员进入软件开发这个领域是因为他们对软件开发充满了热情。任何你热爱的事情都非常容易导致你对它产生一些非常不客观的看法。</p>
<p>拿体育迷来举个例子，我自己并不是一个体育迷，但我知道不同种类运动的粉丝笃信他们支持的队伍是最牛逼的，尽管所有的证据都指向了相反的方向。</p>
<p>对自己选择和想法的捍卫是人类的天性。<strong>我们容易采纳新的相法，但是我们虔诚地捍卫我们已有的，而不需要太多的证据来支持他们。</strong>问题在于我们倾向于把我们对事情的看法与我们的身份，甚至我们作为人的价值捆绑在一起。</p>
<p>需要灵魂深处的搜索，但是如果你看一下你自己，你很有可能会发现，你可以列举出最好的操作系统，编程语言以及框架等等。</p>
<h2>无知不是福</h2>
<p>这种自我强加的信仰导致的问题是，它让我们看不到真相。</p>
<p>在我真正使用了一台Mac之前，我曾经花了无数时间争论它为什么这么垃圾。具有讽刺意味的是，我现在正在一台Mac上面写这篇文章，但我通过远程桌面使用Windows Live Writer来写。而且实际上，这个博客被托管在一个云端Ubuntu服务器的一个PHP应用上，你可能听过它的名字，叫做WordPress。</p>
<p>我的观点是，我们大多数人极力争辩我们选择的技术是最好的，而甚至没有尝试过别的技术。</p>
<p>想象一下，似乎很可笑。但是甚至今天，我都能发现我在这么做。</p>
<p>当我审视我自己，问自己为什么的时候，我发现，大部分动机来自于，我对我所学到的和掌握的知识的自豪和对我所不知道的知识的恐惧这两者的结合。</p>
<p><strong>我发现，如果花一些时间学习一门技术并了解为什么别人这么喜欢它，我就不会如此轻易地把我不知道的技术当做“垃圾”或者“废物”一样扔掉。</strong>正如他人所说，一个人的垃圾正是另一个人的宝藏。</p>
<h2>关于无脑信仰的问题</h2>
<p>即使我不告诉你，你也知道，在这个世界上，无脑(脑残)的狂热是一股毁灭性的力量。你只需要去你最喜欢的国家新闻网站或者读一点历史就知道怎么回事了。</p>
<p><img src="../../../../images/20130801/3.jpg" alt=""></p>
<p><a href="http://simpleprogrammer.com/2013/05/06/why-javascript-is-doomed/" target="_blank">尽管没有太多程序员会挑起PHP vs C#的争议，但是，很多开发者喜欢大声争论自己的意见，甚至盛气凌人地推翻他人的工作。我相信你们一定看到过很多这样的情景，如果你们常常上网的话。当我有胆量发表一些关于JavaScript的负面文章时，我自己也吞下了这样的苦水</a>(这里原文嵌套了太多从句，水平有限，截取了句子主干，如果有兴趣，请阅读原文)。</p>
<p>所以，我们可能觉得，我们的无知并没有伤害任何人，并且我们觉得他们活该因为他们明显是错的，然而真相是，我们的无知留下了相当多的破坏。</p>
<p>回首过去，我感到非常羞愧，因为我将Perl程序员贬低得一无是处，完全否定他们的劳动成果，并且非常无知地推举我神圣的静态类C语言为可以净化他们的唯一救世主。</p>
<p>但是最重要的是，我发现我伤害的其实是我自己。</p>
<h2>别再打自己脸了，傻逼！</h2>
<p>我职业生涯最大的成长得益于，在我寻找一份C#开发的工作时，得到了一个非常好的机会去做一个JAVA项目的架构师。</p>
<p>我被这个决定折磨得够呛。因为我知道JAVA是垃圾的、邪恶的。JAVA缺少像C#那样的属性，需要手写getter和setter，所以每一个写JAVA代码的人明显是傻逼。</p>
<p>我几乎没有接受那份工作，但是我觉得待遇很好，可以勉强一下自己忍一忍过去算了，就像一个战俘等待有一天我的微软大帝可以拯救我。我想，我至少得脱离那种恶心的JAVA写法。</p>
<p>然而，经过了一些年的开发，编写良好的JAVA代码单元测试之后，我发现，其实不仅JAVA没那么屎，这个语言的一些长处和一些JAVA框架也值得称赞。</p>
<p><strong>更重要的是，我开始意识到我过去的代码偏执为我关上了很多扇门。</strong>我开始觉得，可能我过去所有的技术选择都不一定是最好的。我开始思考，其实许多最流行的技术，它们之间并没有那么大的区别。</p>
<p><strong>我开始意识到，相对于无脑崇拜某个我凑巧选择的技术，广泛地理解一系列技术和编程语言可以使我变得更有价值。</strong></p>
<p>现在，我发现我对单个的技术理解得特别快，因为不再是”eating what I was fed“，我可以用我的大脑去比较和对比不同编程语言和技术之间的区别，这样使我对所有的一切都有了更深的理解。</p>
<p>当我最近把我的博客迁移到<a href="https://www.digitalocean.com/?refcode=e701a0a76767" target="_blank">Digital Ocean的云端linux服务器</a>时，它提醒我，我自身的缺点仍然存在着。</p>
<p>开始的时候，我倾向于选择Windows技术去部署Web应用，但是我难以说服自己，一个月只花$10，就能拥有表现很好的云端Linux服务器不是一个好的选择。</p>
<p>说了这么多，我的观点就是，对技术的选择持封闭态度最后只会伤害你自己并限制你作为一个开发者的个人成长。</p>
<p>(这里又两本很好的书可以帮助你打破这些壁垒：<a href="http://www.amazon.com/gp/product/193435659X/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=193435659X&amp;linkCode=as2&amp;tag=makithecompsi-20" target="_blank">「Seven Languages in Seven Weeks」</a>和<a href="http://www.amazon.com/gp/product/1934356921/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1934356921&amp;linkCode=as2&amp;tag=makithecompsi-20" target="_blank">「Seven Databases in Seven Weeks」</a>)</p>
<h2>没有最好的</h2>
<p>在结束这篇文章之前，我恳求你相信”没有最好的技术或者编程语言“。</p>
<p>我不会侮辱你的智商，说编程语言各有各的好，各自处理不同的情况。因为真相远比这个深刻。</p>
<p>在制作了超过40部非常广泛的技术和编程语言的<a href="http://simpleprogrammer.com/2013/06/02/after-completing-40-online-training-courses-for-pluralsight-what-have-i-learned/" target="_blank">Pluralsight课程</a>之后，我发现了一些真相。</p>
<p>真相是，有很多很好的方法能做成同一件相同的事情，使用不同的工具和技术。</p>
<p>真相是，所有的编程语言和技术都有一些大错误和大弱点。</p>
<p>真相是，你学的不同技术越多，你越能发现大多数技术核心的东西是非常相似的。我指的是，编写软件的核心概念，无关乎技术和编程语言语法。</p>
<p>跟我一样，你也会发现，如果你愿意接受其他技术并且承认自己的无知，并从中学习，那么，不管你去了哪里，你都会找到很多乐于助人的友好人士，他们非常乐于把他们知道的东西教给你。</p>
<p><em>(ps：读了这篇博客，你可能会认为我是个伪君子，因为不久以前，我声称<a href="http://simpleprogrammer.com/2012/12/01/why-c-is-not-back/" target="_blank">C++ was not back</a>以及<a href="http://simpleprogrammer.com/2013/05/06/why-javascript-is-doomed/" target="_blank">JavaScript was doomed</a>)。但我认为，我在这两篇文章中说的是实话，而且我不认为这和我在这篇文章中说的相矛盾。对实际使用过的技术持批判态度是可以的。你没必要喜欢所有的东西。我的观点是，尽管，因为现如今的诸多编程问题，我不喜欢C++，而且我觉得JavaScript不是做Web的最优雅的语言，但我承认这两种语言有他们的长处，并且他们在很多情况下是有效的选择。）</em></p>
]]></content>
    <category scheme="http://brotherb.info/tags/编程感悟/" term="编程感悟"/>
    <category scheme="http://brotherb.info/tags/哲学/" term="哲学"/>
    <category scheme="http://brotherb.info/categories/译文/" term="译文"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[关于指针和动态内存分配]]></title>
    <link href="http://brotherb.info/2013/07/30/c-advanced-topics-1/"/>
    <id>http://brotherb.info/2013/07/30/c-advanced-topics-1/</id>
    <published>2013-07-30T09:24:06.000Z</published>
    <updated>2013-07-31T08:29:44.000Z</updated>
    <content type="html"><![CDATA[<p>最近在家有空的时候，在学习一些基础的东西，如操作系统和C语言。两个体会：</p>
<ol>
<li>C语言非常深奥，尤其是你越往深了学，你就发现你还有很多底层的东西是不知道的。</li>
<li>不同编程语言，它们有时会混淆在一起，增加了思考的难度。</li>
</ol>
<p>对于上面的第2点，归根结底来说是因为不懂底层，不懂内幕，不了解语言的类型系统（所有编程语言的基础都是类型系统）。</p>
<p>最近阅读了一些C语言方面的进阶读物，感受颇深。现在以问答的形式，对这一阶段了解到的东西做一个总结。<a id="more"></a></p>
<h3><strong>指针存的是什么</strong></h3>
<hr>
<p>答：指针里面只存一个内存地址。一个指针占多少个字节<strong>取决于机器</strong>。如：32位为4个字节，64位为8个字节(简单起见，<strong>以下所有讨论都只针对32位平台</strong>)。</p>
<h3><strong>是吗？帮我解释一下这件事：</strong></h3>
<hr>
<figure class="highlight lang-C"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="title">int</span> *p1;
<span class="title">char</span> *p2;
<span class="title">p1</span>++;
<span class="title">p2</span>++;
</pre></td></tr></table></figure>

<p>这里，p1实际上加了4,也就是一个int的长度。p2加了1,也就是一个char的长度。指针加减，步长总是等于它所指的类型的长度，那么这个长度的信息（即：它所指类型的信息），指针应该保存吧？</p>
<p><strong>答：不，你想多了，这是编译器要考虑的问题。</strong></p>
<h3><strong>那好，请再帮我解释一下这件事：</strong></h3>
<hr>
<figure class="highlight lang-C"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">int</span> <span class="variable">*p</span> = (<span class="keyword">int</span> <span class="variable">*)</span>malloc(<span class="number">100</span><span class="variable">*sizeof</span>(<span class="keyword">int</span>));
free(p);
</pre></td></tr></table></figure>

<p>这里，我首先在堆上分配了100×4个字节的内存，然后把这段内存(开头)的地址给了p指针。那我free(p)的时候，我怎么知道我要释放400个字节？指针应该有保存这个信息吧？</p>
<p><strong>答：不，你想多了，这是编译器(和操作系统)要考虑的问题。</strong></p>
<h3><strong>数组名就是指针吧？</strong></h3>
<hr>
<figure class="highlight lang-C"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
<span class="keyword">int</span> <span class="variable">*p</span> = a;
<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, a[<span class="number">3</span>]);
<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, p[<span class="number">3</span>]);
</pre></td></tr></table></figure>

<p>你看，这俩基本上就一样嘛。都能通过下标来引用数组中的元素。</p>
<p><strong>答</strong>：错了。数组名是个常量，它的值就是第一个元素的地址，<code>int *p = a;</code>等价于<code>int *p = &amp;a[0];</code>。而指针是个变量。声明数组<code>a[5]</code>的时候，会给你分配20个字节;而声明<code>int *p</code>的时候，只给你分配4个字节。至于你说的下标引用，只是编译器处理的时候，赋予相同的操作而已。<code>a[x]</code>，相当于<code>*(a+x)</code>，根据加法交换律，也就等于<code>*(x+a)</code>。<strong>所以，<code>a[3]</code>也可以写成<code>3[a]</code>，不信你试试。</strong></p>
<h3><strong>函数传参的两种方式：值传递和地址传递的区别？</strong></h3>
<hr>
<p><strong>答</strong>：你看的是谭浩强的「C语言程序设计」书吗？那从现在开始，把那些“传引用，传地址，传指针”这些说法统统扔掉，C语言传参只有<strong>一种</strong>方式：就是<strong>值传递</strong>。地址难道不是值吗？为什么要把它搞的那么复杂？一个变量，它一出生就有两个“值”，<strong>一个是它内存里面存放的位序列，另一个就是它的地址。</strong></p>
<p>考虑以下两个函数：</p>
<figure class="highlight lang-C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>void swap1(<span class="keyword">int</span> a, <span class="keyword">int</span> b)
{
    <span class="keyword">int</span> temp = a;
    a = b;
    b = temp;
}
void swap2(<span class="keyword">int</span> <span class="variable">*a</span>, <span class="keyword">int</span> <span class="variable">*b</span>)
{
    <span class="keyword">int</span> temp = <span class="variable">*a</span>;
    <span class="variable">*a</span> = <span class="variable">*b</span>;
    <span class="variable">*b</span> = temp;
}
<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;
    swap1(a, b);
    swap2(&a, &b);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>调用swap1的时候，swap1在它的栈空间内创建了两个int型变量，分别把a和b的内容赋给它们。调用swap2的时候，swap2在它的栈空间内创建两个int型的指针变量，分别把a和b的地址赋给它们。函数声明和函数调用这两个语句就像是两截管子拧在一起一样(这个比喻懂吧？)。</p>
<h3><strong>malloc(size_t)到底分配了多少内存？</strong></h3>
<hr>
<p><strong>答</strong>：有两种情况</p>
<ol>
<li>在失败的情况下是0,并返回一个NULL指针。</li>
<li>在成功的情况下分配大于size_t的内存</li>
</ol>
<p>第二种情况的产生的原因是两方面的。一方面，在学习操作系统存储器管理的时候，我们知道有<strong>“内存空闲块链表”</strong>这样的东西，这个链表每个节点保存一段空闲内存的信息。在分配内存的时候，系统将这个节点分配给了我们，连同节点里面的内存描述信息也一起分配了，如：这块内存有多大，下一块空闲块的地址等(就像我们摘苹果的时候，会把一些额外的树枝也扯下来)。这造成了一部分开销。另一方面，出于减少内存碎片的考虑，要进行内存对齐，<strong>这部分具体请看参考资料第3篇</strong>。</p>
<p>所以，malloc总是会多消耗一些内存。这里就回答了上面提到的free()函数怎么知道要释放多少内存的问题，答：从分配到的内存块(信息头)中获取到的。所以如果不小心修改了这些内存块的信息头，在释放的时候极有可能导致程序崩溃。</p>
<h3><strong>为什么malloc这么慢？</strong></h3>
<hr>
<p>答：这个问题也可以这么问：为什么堆内存分配这么慢，或，为什么动态内存分配这么慢？原因很简单，<strong>因为堆内存分配比较复杂</strong>。具体怎么复杂，<strong>请看参考资料第5篇</strong>。</p>
<h3><strong>如何提高malloc的性能？</strong></h3>
<hr>
<p><strong>答</strong>：这个问题问的也有问题，你想问的可能是：我这里大量使用了动态内存分配，应该如何提高程序的性能？答：<strong>减少malloc的调用次数</strong>。如：一次分配一个较大的内存块，或者，在不必要的情况下，不要使用动态内存分配。</p>
<p>「编程珠玑」p136中说道:</p>
<blockquote>
<p>最显著的改进就是用只分配一个较大内存块的方案来替换通用内存分配。这样就消除了很多开销较大的调用，而且也使空间的利用更加有效率。</p>
</blockquote>
<p>细细想来，很多优化也确实这样做的。如C++ STL中的vector,list等数据结构，以及Python中的PyListObject和PyDictObject对象。</p>
<h3><strong>参考资料</strong></h3>
<hr>
<ol>
<li>[「C和指针」第二版]</li>
<li><a href="http://pw1.netcom.com/~tjensen/ptr/pointers.htm" target="_blank">A TUTORIAL ON POINTERS AND ARRAYS IN C</a></li>
<li><a href="http://blog.csdn.net/elpmis/article/details/4500917" target="_blank">关于glibc的malloc内存对齐</a></li>
<li><a href="http://prog21.dadgum.com/179.html" target="_blank">How much memory does malloc(0) allocate?</a></li>
<li><a href="http://mikehearn.wordpress.com/2006/10/26/why-is-heap-allocation-slow/" target="_blank">why is heap allocation slow</a></li>
</ol>
]]></content>
    <category scheme="http://brotherb.info/tags/C语言/" term="C语言"/>
    <category scheme="http://brotherb.info/categories/C/" term="C"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[程序员的老生常谈之开发工具]]></title>
    <link href="http://brotherb.info/2013/07/27/programmer's-platitude1/"/>
    <id>http://brotherb.info/2013/07/27/programmer's-platitude1/</id>
    <published>2013-07-27T12:08:14.000Z</published>
    <updated>2013-08-25T05:56:46.000Z</updated>
    <content type="html"><![CDATA[<h3><strong>楔子</strong></h3>
<hr>
<p>自从我学习软件工程以来，我看到了一个有趣的现象：程序员们中间经常爆发圣战，战况空前激烈，为了自己的主义，常常争的面红耳赤，一副“来信砍”的姿态。我有时也会加入战局，并从中能拓宽一些知识面，了解到不同领域的技术状况。</p>
<p>程序员们讨论的话题相当多，但对于一些月经话题，我现在基本上是视而不见的，比如以下几种：</p>
<ol>
<li><strong>IDE vs 文本编辑器 || Vim vs Emacs || 用xxx语言编程，你们用什么IDE or 编辑器？</strong></li>
<li><strong>Windows vs Linux vs osX</strong></li>
<li><strong>C/C++ vs JAVA vs C# vs Python vs Ruby vs …</strong><br><a id="more"></a><h3><strong>一些看法</strong></h3>
</li>
</ol>
<hr>
<p>对于第一个问题，简而言之，就是工具的选择。工欲善其事，必先利其器。当然了，使用什么工具是大家的自由，<strong>爱用什么用什么就行了</strong>。这里，主要写给那些长时间纠结Emacs or Vim的programmers，如果你(们)努力尝试过使用这个神器，但是始终没有进入理想的状态，你也许可以听听我的看法。</p>
<p>首先，我推荐各位看客读一下王垠的<a href="http://www.yinwang.org/blog-cn/2013/04/20/editor-ide/" target="_blank">「编辑器与IDE」</a>一文。完全赞同他的观点。</p>
<p>他在文中提到：</p>
<blockquote>
<p>很多人对 IDE 有偏见，因为他们认为这些工具让编程变得“傻瓜化”了，他们觉得写程序就是应该“困难”，所以他们眼看着免费的 IDE也不试一下。</p>
</blockquote>
<p>这是实话。程序员(尤其是爱折腾的程序员)往往喜欢故意为自己增加一些难度，并享受在高难度下完成任务的成就感，有时候他们所作的甚至偏离了要解决的问题本身。比如，程序员A说：”哈哈哈，我写了一个xxx，纯拿记事本写的，众屌丝速来跪舔！”或者，程序员B说：“哈哈哈，我写了一个xxx，但我用的是汇编语言！”下面一帮程序员随声附和。“膜拜！”“orz！”。其实，程序员可以不用活的那么累，用IDE省些时间吧，多陪陪老婆孩子，多运动一会。也有一句至理名言是这么说的：<strong>人生苦短，我用python</strong>。所以，<strong>要用对的，不用难的</strong>。</p>
<p>另一方面，有一部分程序员喜欢装逼。所以，“Emacs，是一种信仰”便成为了他们的口头禅，开口闭口Emacs，鄙视别人用IDE。殊不知，<strong>拉开差距的并不是你用什么工具，而是你拥有什么知识，你有什么眼界，你知道怎么做人</strong>。</p>
<p>剩下的就是真正的Emacs程序员了。一些老程序员并不认为用Emacs是增加难度，因为他们用惯了，vim和emacs诞生的年代早于现代通用keyboard shortcuts被标准化的时间(参考<a href="http://windows.appstorm.net/general/opinion/know-where-your-keyboard-shortcuts-come-from/" target="_blank">这里</a>)，所以他们从一开始就使用这么(我们认为)难的玩意，自然不可同日耳语。当然还有很多新程序员很牛，能真正发挥Emacs的威力，我在这里表示尊敬。</p>
<p>更多精辟的见解，请直接移步<a href="http://www.yinwang.org/blog-cn/2013/04/20/editor-ide/" target="_blank">「编辑器与IDE」</a>一文。我在这里就不复制粘贴了。</p>
<h3><strong>我用什么</strong></h3>
<hr>
<p>就个人来说，我是IDE的坚定支持者，我觉得道理很简单，在有洗衣机的情况下还用手洗衣服是不明智的，在有(非常好的)IDE的情况下故意使用一些老古董，<strong>我认为是一种退步</strong>，当然，我指的是做大项目的情况下，小代码都可以。我最喜欢的IDE是微软的<strong>Visual Studio</strong>，还有<strong><a href="http://www.jetbrains.com/" target="_blank">JetBrains</a></strong>的编程工具系列。Vim和Emacs都玩过，当然，只是玩过，即：配置各种东西。这两个东西确实很好玩，很神奇，扩展性非常强，你可以给它们配各种add-ons和plugins，然后enhance它们的features。</p>
<p>有段时间，我决定做一个<strong>Hardcore Geek</strong>，使用Vim和Emacs来编程，为此，我配置了C++和python的开发环境。配置的过程是非常的愉快的，好玩。配好了以后，我觉得很神奇，确实“能用”，功能都实现了。但，也仅仅是“能用”而已，远没有传说的那么牛逼。而我追求的是，好用。首先，需要记忆的东西很多，按键复杂，尤其是Emacs。其次，不够智能。很遗憾，我没有在<a href="http://en.wikipedia.org/wiki/Richard_Stallman" target="_blank">Richard Stallman</a>的时代投身到计算机的世界中，那时候没啥好用的IDE，程序员只能用这些家伙来写代码，并且，确实写出了很多好的软件。使用这些编辑器的人现在都挺牛逼的。可能借助牛人的光环，以及一些程序员(尤其是老程序员)的宗教情节，外加有些程序员爱装逼。这两个编辑器被成为“<strong>编辑器之神</strong>”和“<strong>神之编辑器</strong>”，被推到了一个相当高的高度。我承认这两个名头确实有那么点意思，Vim的凭借它的编辑功能，最神的编辑器当之无愧;另一方面，使用Emacs的程序员之中有很多是大神级别的。</p>
<p>目前来讲，我在使用linux的时候，会使用Vim编辑一些配置文件或者别的什么文本文件。东西好，得承认，在强大的编辑功能面前，我没啥话说。但不拿来写代码。Emacs的话，上次折腾它的新鲜劲过去了，说不定那天会改变主意，试着看看能不能用它来写点clojure之类的，我听一些人说，用Emacs写CL/elisp/clojure这些函数式语言，效果确实好。</p>
<p>至于很多人在说效率的问题，<strong>一些IDE的编辑器可不像windows自带的记事本那么傻逼</strong>。你可以去看官方的Manual，里面包含了很多的tricks，shortcuts，snippets etc.</p>
<ul>
<li><p>关于Visual Studio，我推荐一本书<a href="http://www.microsoft.com/MSPress/books/13221.aspx" target="_blank">「Microsoft Visual Studio Tips」</a>。里面有很多有用的tips，如果能全部掌握，我保证，你的效率绝对不会差。如果你还是觉得不够，你可以安装<a href="http://visualstudiogallery.msdn.microsoft.com/59ca71b3-a4a3-46ca-8fe1-0e90e3f79329/" target="_blank">VsVim</a>这个插件，将Vim的编辑能力和VS的项目管理能力和强大的调试能力相结合，你，将是无敌的存在。</p>
</li>
<li><p>关于JetBrains的产品，我觉得真心好。爱美是人的天性。没有人会喜欢丑陋的东西。所以苹果的产品卖的好。JetBrains的东西，就一个字，<strong>美</strong>。一直以来，我以为Java是做不出什么好UI的(设计模式课上见识了很多java写的桌面软件，基本上都丑的一逼)，eclipse已经是它的极限了，至于为什么，请看<a href="http://www.zhihu.com/question/19711713" target="_blank">这里</a>。但我没想到，JetBrain的开发工具，都是用java做的。它是对程序员最友好的IDE，他的配置极其方便，(<strong>我认为VS在这方面要向JetBrains好好学习一下</strong>)，并且它非常智能。目前我使用Intellij IDEA来写java和clojure，使用PyCharm写Python程序，体验非常好。</p>
</li>
<li><p>文本编辑器我使用<strong><a href="http://www.sublimetext.com/" target="_blank">Sublime Text2</a></strong>多一些，这篇文章就是用Sublime编辑的。有时候，虽然有一些小问题(至于什么问题，有空再聊)，但瑕不掩瑜。Sublime用户体验非常好，美观，优雅，扩展性不错，插件也还算多。算是Vim的小DD吧。</p>
</li>
</ul>
<h3><strong>一些说明</strong></h3>
<hr>
<p>关于以上提到的工具：</p>
<ul>
<li><p>Visual Studio我使用的是Visual Studio 2012 Express For Windows Desktop，免费的。我喜欢简洁，不喜欢无关的东西，Visual Studio 2012就算在安装的时候去除所有的components，还是会给你装一些无关的东西(Express也会装，但是装的少一些)，如VB，F#，silverlight，sql server express等等n多用不到的东西。目前我需要的只是一个C/C++/C#的IDE。Express版的缺点是不能装插件，如Visual AssistX，PTVS(Python Tools for Visual Studio)，都装不了，凑和着用吧，结合上文提到的「Microsoft Visual Studio Tips」，用着还行。如果是学生朋友，请利用这一便利，你可以从<a href="https://www.dreamspark.com/Student/Software-Catalog.aspx" target="_blank">这里</a>免费得到微软的大部分开发工具。如果既想简洁，高定制性，又想装插件，还不想受“使用盗版软件”这一良心的谴责，请看<a href="http://www.cnblogs.com/xiaotie/archive/2013/02/22/2922204.html" target="_blank">「DIY 一套正版、免费、强大的 Visual Studio 2012 IDE」</a>一文。</p>
</li>
<li><p>Intellij IDEA使用的是社区版，free of charge，通过安装插件的方式，你可以把它扩展成为别的一些语言的IDE，如clojure，具体方法自行谷歌。</p>
</li>
<li>Sublime Text 2一个licence是70刀，但是你不注册也可以使用，只不过偶尔会给你弹个框。<strong>阿里噶多，哦赛衣妈斯！好人一生平安！</strong></li>
<li>PyCharm在30天的试用期后，<strong>我选择了破解，惭愧</strong>。。。</li>
</ul>
<h3><strong>postscripts</strong></h3>
<hr>
<ol>
<li>关于D版和破解，由于现在尚且处于<strong>学生狗</strong>的阶段，我尽量使用免费的版本，对于特别喜欢的东西，只好说声抱歉了先，等工作了一定入正。</li>
<li>本来还想讨论剩下的两个问题，但是已经写了这么多了，就下次再聊吧～</li>
<li>(几乎)对于linux下的C/C++，IDE也是有选择的，如eclipse+CDT和code::blocks，但我觉得上次配的Vim环境也还凑和，或许也是一个不错的选择，主要是我对Vim还算比较熟。</li>
<li>本文4000多字，写完感觉不累，<strong>远比2000字的事迹材料，或者思想汇报要好得多啊</strong>。</li>
</ol>
]]></content>
    <category scheme="http://brotherb.info/tags/IDE/" term="IDE"/>
    <category scheme="http://brotherb.info/tags/编辑器/" term="编辑器"/>
    <category scheme="http://brotherb.info/categories/闲聊/" term="闲聊"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[关于此博客]]></title>
    <link href="http://brotherb.info/2013/07/26/about-this-blog/"/>
    <id>http://brotherb.info/2013/07/26/about-this-blog/</id>
    <published>2013-07-25T16:49:11.000Z</published>
    <updated>2013-11-10T18:07:45.000Z</updated>
    <content type="html"><![CDATA[<h3><strong>缘由</strong></h3>
<hr>
<p>很久以来就想弄一个博客，终于在这个暑假有时间有精力，决定做一个属于自己的独立博客，记录一些自己在生活和学习方面的体会。对于「为什么要写博客」这个问题，读者可以看一下刘未鹏的这篇<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank">「为什么你应该(从现在开始就)写博客」</a>。这是一篇很长的文章，耐心看下去。</p>
<p>就自身而言，<strong>我觉得写博客是一件很cool的事情</strong>。我常常能从别人的博客中汲取到很多东西，技术的或者是非技术的。怀着一颗感恩的心，我试图也去写博客去分享自己的知识，可惜某些思想上的壁垒总是难以逾越，比如：</p>
<ul>
<li><strong>我写不出什么东西来</strong></li>
<li><strong>我写给谁看？</strong></li>
</ul>
<p>我曾经想破了头，试图写出一篇惊世骇俗的文章。读过之后，会让人有种醍醐灌顶、豁然开朗的感觉。<a id="more"></a>经过长时间的思考，写不出来。技术上，自己尚且不够牛逼，能写的无非是一些网上随便一搜就能搜得到的东西。人生的感悟？对于一个只活了二十来岁的人来说，未免贻笑大方。另一方面，虽然我有我自己的人生哲学、价值观、point of view(可能是不成熟的)，有时候还感觉自己的认识很深刻，够写5000字了，但是想要付诸笔端的时候却不知道该说什么了。</p>
<p>这最起码说明了我存在的两个问题。</p>
<ol>
<li><p><strong>不总结</strong>。导致的结果：学的快，忘的也快，即，当时”会了“，现在又不会了。会者不难，对于会了的东西，人总是觉得很简单，而忘记了当时自己花了多大的功夫才学会的，长时间再也不去管，结果就是下次问你的时候，你挠了挠头，说道：“噢，大概是。。。当时我好像。。。”。这次遇到问题要google，下次还要google。</p>
</li>
<li><p><strong>不善于归纳</strong>。无法把心中看似条理，实则杂乱的念头(潜意识)整理成一条戒律，一条格言。往往是，当有人说出一番十分有哲理的话，赢得满堂喝彩时，心说：<strong>我其实也是这么想的</strong>。可你就是说不出来。这里推荐一篇文章<a href="http://wangcong.org/blog/archives/2106" target="_blank">「为什么你不应该爱国」</a>，我觉得写得非常深刻。</p>
</li>
</ol>
<p>花了很多时间学会的东西，应当花更多一点的时间去记住它。不管这个东西网上有没有，自己过一遍，认真写成文章，印象要深好几倍。这也回答了我上面的第二个问题，博客写给谁看？答：<strong>主要是写给自己看</strong>。这是一个<strong>梳理知识</strong>，<strong>加深记忆</strong>的过程，也是一个<strong>思考</strong>的过程。当然，我十分乐意帮助遇到相同问题的人少走一些弯路。同时，也能锻炼自己坚持的品质。</p>
<h3><strong>搭建</strong></h3>
<hr>
<p>现在说说，这个博客怎么搭建的。</p>
<p>首先，博客有两种类型：</p>
<ol>
<li>由门户网站免费提供的一种服务。扯淡方面，新浪博客，qq空间，人人等(当然，这些地方也有少数做技术的人才);技术方面，博客园，CSDN，Javaeye等。轻博客也算吧，像点点网(玩过一段时间)，网易的lofter，Tumblr(要翻墙)。这些我基本都有接触过一些，qq空间也曾大放厥词。但觉得，作为一个技术型人员，或一个想成为Geek的人来说，还不够，不够cool。</li>
<li>独立博客。这里分两种吧。一种是自己租<a href="http://en.wikipedia.org/wiki/Virtual_private_server" target="_blank">vps</a>，另一种是托管，比如GAE,SAE,BAE这样的云平台，或者是Github. 对于第一种，大多数人租vps有别的用处(爬虫，跑自己写的一些小网站什么的)，否则只放一个博客在上面实在是大材小用了。</li>
</ol>
<p>我使用的是Github提供的一个叫做Github pages的服务or功能，即把一些网页托管在Github上，别人能访问。好处有很多，比如：</p>
<ul>
<li>借助Git强大的版本控制功能，妈妈再也不用担心我丢东西了</li>
<li>完全DIY</li>
<li>免费</li>
<li>静态页面，速度快，轻量级(相对于wordpress)</li>
<li>访问速度快(天朝可能会慢点)</li>
<li>可以设独立域名</li>
<li>…</li>
</ul>
<p>基本思路就是：<strong>用静态页面生成工具，把符合一定语言规范(markdown，或者别的一些模板语言)的文本处理成静态网页</strong>。然后放到Github上去。详情请看Github pages<a href="https://help.github.com/categories/20/articles" target="_blank">帮助文档</a></p>
<p>对于静态页面生成器，我曾经有如下选择：</p>
<ol>
<li>Jekyll(Github标配，默认界面比较丑，要做的事情太多)</li>
<li>JekyllBootstrap(Jekyll进一步封装，用了Bootstrap库)</li>
<li>Octopress(也是基于Jekyll的，但貌似生成步骤要更麻烦一些)</li>
<li>Hyde(主要是因为看了<a href="http://stevelosh.com/" target="_blank">这个人</a>的博客)</li>
<li>Hexo(最简单，最快)</li>
</ol>
<p>最终我选择了Hexo。不选前四者的原因很多，选Hexo的原因只有一个，它<strong>最简单</strong>，只有几条简单的命令,<strong>渲染速度最快</strong>。</p>
<p>Hexo具体的使用方法我就不讲了，这里有很多很好的参考资料：</p>
<ul>
<li><a href="http://zespia.tw/hexo/" target="_blank">官方文档</a></li>
<li>这位同学的<a href="http://zipperary.com/categories/hexo/" target="_blank">系列教程</a>，写的非常清楚。</li>
<li>这篇<a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank">文章</a></li>
</ul>
<p>其实都能google到。有兴趣的可以试一下，还是挺有意思的。</p>
<h3><strong>展望</strong></h3>
<hr>
<p>老实说，这两天的时间都交代在这上面了，学到了很多东西。希望这是一个好的开始，希望自己能坚持下去，希望今后的岁月中能积淀下一些精华，而不是像过去的四年一样留下一片空白。</p>
]]></content>
    <category scheme="http://brotherb.info/tags/hexo/" term="hexo"/>
    <category scheme="http://brotherb.info/tags/github/" term="github"/>
    <category scheme="http://brotherb.info/tags/blog/" term="blog"/>
    <category scheme="http://brotherb.info/categories/闲聊/" term="闲聊"/>
  </entry>
</feed>
